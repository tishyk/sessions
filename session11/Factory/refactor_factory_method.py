# Factory/shapefact1/ShapeFactory1.py
# A simple static factory method.
# from __future__ import generators  # for subclasses access in python 2.x
import random
import abc

class Shape(abc.ABC):
    # Create based on class name:
    @classmethod
    def create_shape(cls):
        return cls()

    @abc.abstractmethod
    def draw(self):
        pass

    @abc.abstractmethod
    def erase(self):
        pass


class Circle(Shape):

    def draw(self):
        print("Circle.draw")

    def erase(self):
        print("Circle.erase")


class Square(Shape):
    def draw(self):
        print("Square.draw")

    def erase(self):
        print("Square.erase")

class Triangle(Shape):
    def draw(self):
        print("Triangle.draw")

    def erase(self):
        print("Triangle.erase")

# Generate shape name strings:
def shapeNameGen(n):
    types = Shape.__subclasses__()
    print(types)
    for i in range(n):
        item = random.choice(types)
        print(item)
        yield item


chairs = [class_type.create_chair() for class_type in shapeNameGen(7)]
tables = [class_type.create_table() for class_type in shapeNameGen(7)]



for chair in chairs:
    chair.window = chair.open_window('Settings')
    chair.window.disable_notification('')
    chair.run()
    chair.cleanup()

for table in tables:
    table.window = table.open_window('Settings')
    table.window.disable_notification('')
    table.run()
    table.cleanup()

"""
Inside the generator-factory, you can see the call to __subclasses__( ), which produces a list of references to each of
the subclasses of Shape (which must be inherited from object for this to work). You should be aware,
however, that this only works for the first level of inheritance from Item,
so if you were to inherit a new class from Circle, it wouldn’t show up in the list generated by __subclasses__( ).
If you need to create a deeper hierarchy this way, you must recurse the __subclasses__( ) list.

Also note that in shapeNameGen( ) the statement:

types = Shape.__subclasses__()
Is only executed when the generator object is produced; each time the next( ) method of this generator object is called
(which, as noted above, may happen implicitly), only the code in the for loop will be executed,
so you don’t have wasteful execution (as you would if this were an ordinary function)."""
